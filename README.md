# README.md

# GitHub Copilot Statistics App

This project is an experimental venture into **vibe coding**, an AI-assisted approach where software is developed through natural language prompts, allowing the AI to generate the corresponding code. citeturn0search3 In this context, all code within this repository has been generated by GitHub Copilot, with human intervention limited to debugging during development.

The application is built using Streamlit, providing an interactive web interface for data visualization and analysis of GitHub Copilot usage telemetry. The primary objective is to evaluate GitHub Copilot's capabilities by developing a fully functional application without manually writing any code.

Please note that, as an experimental project, it remains a work in progress. The code has not undergone comprehensive human review beyond necessary debugging during development.

## Project Structure

The repository is organized with a containerized architecture, where application code and dependencies are structured for efficient deployment:
```
.
├── .github                         # GitHub related configuration
│   ├── copilot-instructions.md     # Instructions for GitHub Copilot
│   ├── other-instructions/         # Additional instruction files
│   └── prompts/                    # Prompt templates for AI interactions
├── .vscode                         # VS Code editor configuration
│   ├── launch.json                 # Debug configurations
│   └── settings.json               # Editor settings
├── app                             # Application container directory
│   ├── .dockerignore               # Files excluded from Docker builds
│   ├── .env                        # Environment variables configuration
│   ├── .env.local                  # Local environment overrides
│   ├── Dockerfile                  # Container definition for app
│   ├── requirements.txt            # Python dependencies
│   ├── .streamlit/                 # Streamlit-specific configurations
│   ├── data/                       # Directory for persistent data storage
│   └── src/                        # Application source code (detailed below)
├── docs                            # Documentation files
│   ├── lessons_learned.md          # Project insights and learnings
│   └── relevant_prompts.md         # Documentation of effective prompts
├── infrastructure                  # Azure deployment resources
│   ├── acr.bicep                   # Azure Container Registry definition
│   ├── build.sh                    # Script for Docker image building
│   ├── config.local.sh             # Local configuration settings
│   ├── defender.bicep              # Azure Defender configuration
│   ├── deploy.sh                   # Main deployment script
│   ├── main.bicep                  # Primary Bicep deployment template
│   ├── parameters.*.json           # Environment-specific parameter files
│   └── archive/                    # Archived infrastructure files
├── .macos                          # macOS virtual environment
├── README.md                       # Project documentation
└── .gitignore                      # Git ignore patterns

```

This structure reflects the containerized approach, where the application code and dependencies are organized within the `app` directory for deployment.

### Source Code Structure

The `app/src/` directory contains the application's source code with the following organization:

```
app/src/
├── app.py                    # Main Streamlit application entry point
├── auth/                     # Authentication related code
│   ├── __init__.py
│   ├── azure_auth.py         # Azure authentication implementation
│   └── session.py            # Session management utilities
├── data/                     # Data processing and storage
│   ├── __init__.py
│   ├── api.py                # GitHub Copilot API client
│   ├── database.py           # SQLite database operations
│   └── models.py             # Data models and schemas
├── pages/                    # Streamlit multi-page application structure
│   ├── 1_charts.py           # Data visualization charts
│   ├── 2_trends.py           # Trend analysis page
│   └── 3_settings.py         # Application settings page
└── utils/                    # Utility functions and helpers
   ├── __init__.py
   ├── config.py             # Configuration management
   ├── constants.py          # Application constants
   ├── helpers.py            # General helper functions
   └── visualization.py      # Visualization utilities
```

## Installation

1. Clone the repository:
   ```
   git clone <repository-url>
   cd streamlit-app
   ```

2. Install the required packages:
   ```
   pip install -r requirements.txt
   ```

## Running the Application

To run the Streamlit application, use the following command:

```
streamlit run src/app.py
```

## Azure Deployment

### Prerequisites

- Azure CLI
  ```bash
  brew install azure-cli
  ```
- Docker
  ```bash
  brew install docker
  brew install jq
  ```
- Azure subscription with admin access
- Access to Azure Entra ID with admin privileges

### 1. App Registration in Entra ID

1. Go to Azure Portal > Microsoft Entra ID:
   - Select "App registrations" from the left menu
   - Click "New registration"

2. Register the application:
   - **Name**: "GHCP Stats"
   - **Supported account types**: Select "Accounts in this organizational directory only (Single tenant)"
   - **Platform configuration**: Select "Web"
   - **Redirect URI**: For local development, use exactly `http://localhost:8501` (no trailing slash)
   - Click "Register"

3. Configure authentication:
   - Go to "Authentication" in the left menu
   - Under "Platform configurations":
     - Verify the Web platform is configured
     - For production, add `https://<your-app-name>.azurecontainer.io` (no trailing slash)
   - Under "Implicit grant and hybrid flows":
     - ✅ Check "Access tokens (used for implicit flows)"
     - ✅ Check "ID tokens (used for implicit and hybrid flows)"
   - Under "Advanced settings":
     - Set "Allow public client flows" to "No"
     - Set "Enable the following mobile and desktop flows" to "No"
   - Click "Save"

4. Configure token settings:
   - Go to "Token configuration" in the left menu
   - Click "Add optional claim"
   - Add the following claims to the Access token:
     - `email`
     - `preferred_username`
   - Click "Add"

5. Configure API permissions:
   - Go to "API permissions" in the left menu
   - Click "Add a permission"
   - Select "Microsoft Graph"
   - Select "Delegated permissions"
   - Add these permissions:
     - `User.Read` (default)
     - `email`
     - `offline_access` (for refresh tokens)
     - `profile`
   - Click "Add permissions"
   - Click "Grant admin consent" button (requires admin)

6. Create client secret:
   - Go to "Certificates & secrets" in the left menu
   - Under "Client secrets":
     - Click "New client secret"
     - Description: "GHCP Stats App Secret"
     - Expires: Select appropriate duration (e.g., "12 months")
     - Click "Add"
   - ⚠️ **IMPORTANT**: Copy the secret value immediately - it won't be shown again

7. Required configuration values:
   ```
   Application (client) ID: Found in Overview
   Directory (tenant) ID: Found in Overview
   Client Secret: Value copied in step 6
   Redirect URI: http://localhost:8501 (development)
                https://<your-app-name>.azurecontainer.io (production)
   ```

8. Update environment variables:
   ```bash
   # Local development (.env.local)
   AZURE_CLIENT_ID="your-client-id"
   AZURE_APP_CLIENT_SECRET="your-client-secret"
   AZURE_TENANT_ID="your-tenant-id"
   REDIRECT_BASE_URL="http://localhost:8501"
   ```

### Important Security Notes:

- Redirect URIs must match exactly (no trailing slashes)
- Never commit secrets to version control
- Use managed identities in production when possible
- Store secrets in Azure Key Vault
- Implement token refresh logic
- Monitor token expiration
- Review permissions regularly
- Implement proper error handling for auth failures

### 2. Infrastructure Deployment

To be corrected since the deployment flow has changed

1. Create Azure resources using Bicep:
   ```bash
   # Login to Azure
   az login

   # Create deployment
   cd infrastructure
   chmod +x deploy.sh
   ./deploy.sh
   ```

2. Configure Key Vault secrets:
   ```bash
   az keyvault secret set --vault-name <vault-name> \
     --name "APP-CLIENT-ID" \
     --value "your-client-id"

   az keyvault secret set --vault-name <vault-name> \
     --name "APP-CLIENT-SECRET" \
     --value "your-client-secret"

   az keyvault secret set --vault-name <vault-name> \
     --name "TENANT-ID" \
     --value "your-tenant-id"

   az keyvault secret set --vault-name <vault-name> \
     --name "GHCP-TOKEN" \
     --value "your-github-token"
   ```

### 3. Container Image Build and Push

1. Build the Docker image:
   ```bash
   docker build -t ghcp-stats:latest .
   # check for vulnerabilities
   docker scout quickview 
   docker scout cves local://ghcp-stats:latest
   docker scout recommendations local://ghcp-stats:latest
   ```

   It's a good idea to test the image locally
   ```bash
   docker run -p 8501:8501 ghcp-stats:latest
   ```

2. Push to Azure Container Registry:
   ```bash
   # Login to ACR
   az acr login --name <registry-name>

   # Tag image
   docker tag ghcp-stats:latest <registry-name>.azurecr.io/ghcp-stats:latest

   # Push image
   docker push <registry-name>.azurecr.io/ghcp-stats:latest
   ```

### 4. Container App Configuration

1. Update Container App with environment variables:
   ```bash
   az containerapp update \
     --name ghcp-stats-app \
     --resource-group ghcp-stats-rg \
     --set-env-vars \
       "AZURE_CLIENT_ID=your-client-id" \
       "AZURE_TENANT_ID=your-tenant-id" \
       "KEY_VAULT_NAME=your-keyvault-name" \
       "DB_NAME=/app/data/metrics.db"
   ```

2. Configure authentication:
   - Go to Container App > Authentication
   - Add identity provider:
     - Provider: Microsoft
     - Tenant type: Workplace
     - Client ID: (from app registration)
     - Client secret: (from app registration)
     - Issuer URL: `https://login.microsoftonline.com/<tenant-id>/v2.0`
   - Configure redirect URIs
   - Enable session management

### 5. Verify Deployment

1. Access the application:
   ```
   https://ghcp-stats-app.<region>.azurecontainer.io
   ```

2. Check logs:
   ```bash
   az containerapp logs show \
     --name ghcp-stats-app \
     --resource-group ghcp-stats-rg \
     --follow
   ```

### Environment Variables

Required environment variables for the application:

| Variable | Description | Source |
|----------|-------------|--------|
| AZURE_CLIENT_ID | App registration client ID | Entra ID |
| AZURE_TENANT_ID | Azure tenant ID | Entra ID |
| KEY_VAULT_NAME | Name of Azure Key Vault | Infrastructure |
| DB_NAME | SQLite database path | Container configuration |
| GHCP_TOKEN | GitHub Copilot API token | Key Vault |

### Troubleshooting

- **Authentication Issues**: Verify app registration and redirect URIs
- **Data Persistence**: Check Azure Files mount and permissions
- **Container Startup**: Review container logs and environment variables
- **Key Vault Access**: Verify managed identity assignments

## Contributing

Feel free to submit issues or pull requests for any improvements or bug fixes.

# TODO

- Inconsistent Import Paths: Some files use relative imports (from utils.helpers) while others use different import styles. Consistency would improve maintainability.
- Page Naming Convention: Using numeric prefixes (1_charts.py) works but Streamlit now supports a pages/ directory with automatic navigation. Consider standardizing your approach.
- Error Handling: Add more robust error handling around database operations and API calls.
- Session State Management: Session state variables are scattered across different files. Consider centralizing this logic.
- Move common Azure resources in a shared resource group
  - keyvault
  - azure container registry
- Use different storage account file shares to differentiate between environments
- Make the auto update setting permanent, persisting it in a config file side by side the metrics db
- Add OpenTelemetry towards Azure Monitor


## Recommendations

- Standardize Page Structure: Use a consistent template for all pages with standard imports and authentication requirements.
- Refactor Authentication Flow: The current authentication implementation seems to have some issues. Consider creating a more robust auth module. Add the authentication button to the side bar and not to the pages.
- Add Documentation: Add docstrings to functions and modules for better code maintainability.
- Implement Logging: Replace print statements with proper logging to help with debugging.
- Cache Heavy Operations: Use @st.cache_data or @st.cache_resource decorators for database queries and API calls.
- Add Tests: Consider adding unit tests for your utility functions and data processing logic.
- Secrets Management: Use Streamlit's secrets management instead of directly accessing environment variables where possible.
- Use a Database Abstraction Layer: Consider using an ORM like SQLAlchemy to make database operations more maintainable

## License

This project is licensed under the GNU Affero General Public License v3.0 (AGPL-3.0). The AGPL-3.0 is a strong copyleft license that requires anyone who distributes or uses this software (even as a network service) to make the complete source code available under the same license.

### Key License Terms

- **Source Code Availability**: If you modify and distribute this software, you must make your modified version available under the AGPL-3.0.
- **Network Use**: If you run a modified version of this software as a service that others can interact with, you must make your modified version available to users.
- **Attribution**: You must retain all copyright notices and license text.

### Important Note on Commercial Usage

This project is primarily intended for non-commercial use. While the AGPL-3.0 technically permits commercial use, the strong copyleft requirements create significant obligations that may make commercial exploitation impractical for many use cases.

For commercial usage inquiries, please contact the project maintainers directly to discuss potential custom licensing options.

See the [LICENSE](LICENSE) file for the complete license text.
